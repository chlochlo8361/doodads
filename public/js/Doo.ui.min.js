/**
 Copyright (c) 2005-2019 Henrik M. Javen, H-Consulting

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/
'use strict'
//import DataItem from "/js/Doo.DataItem.js"
//import FieldType from "/js/Doo.FieldType.js"

const EMPTY_ROW = function() {return new DataItem(item[0],i,[''])}
// TODO research String localeCompare()  and all other String methods that should be part of COMPUTED
const COMPUTED  = {
	//TODO probably should change to class and use Reflects, or have these methods just live in DataItem
	//TODO figure out how todo chaining
	//user Reflect to test all computed
	//TODO change args to dataItem
	greyShade:(args)=>{return ['light-grey','grey','dark-grey','black'][args.i % 4]}, 
	fraction:(args)=>['','whole','half','third','quarter','fifth'][$1], 
	toUpperCase:(args)=>args.getValue().toUpperCase(),
	toLowerCase:(args)=>args.getValue().toLowerCase(),
	substring:(args)=>args.getValue().substring(args.$1,args.$2),
	length:(args)=>args.arr.length,
	count:(args)=>args.arr.length,
	recCountByDataSetKey:(args)=>args.klass[args.dataSetKey].length,  //TODO not tested
	i:(args)=>args.i,
	$id:(args)=>'_$' + args.i,
	n:(args)=>args.i+1,
	ts:()=> new Date().getTime(),
	pluralize:(args)=>args.arr.length > 1 ? 's' : '',
	nbsp:()=>'&nbsp;',
	zeroOne:(arg)=>(arg.i % 2),
	lorem:()=>{
		  let lorem = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.' 
			lorem += 'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.'
		return lorem
	},
	highlight:(args)=>{
    	if (args.item) {
	        let filterKey = args.filterKey && args.filterKey.toLowerCase()
	        if (!filterKey) {return args.item[args.fld]}
	        let re = new RegExp(filterKey, "ig")
	        let value = args.item[args.fld].toString().replace(/&amp\;/gi,'&')
	        //TODO make <b> configurable
	        return value.replace(re, (txt) => {return ('<b>' + txt + '</b>')})
    	}    
    }
  
}
//TODO move back into Doo
class Config {
	static get NAME() {return 'Doo.ui'}
	static get VERSION() {return Config.NAME + 'rc.9'}
	static get TYPE() { return {DEFAULT:0,ENUM:1,DEEP:2,COMPUTED:3 }}
	static get MATCH() { return {ANY:-1,STARTS_WITH:0,EXACT:1}}
	static get DELIMITER() {return {'BEG':'{{','END':'}}'}}
} 

//TODO add regexp to extract todoos and display them in the TODOO and persist them in GitHub via github API
//TODO group the methods in Doo.ui.js in logical sections
class Doo extends HTMLElement {
	static get observedAttributes() {
		return ['implements','doo-db-update','doo-db','doo-theme', 'data-set','index','page-size','debug']
	}
	static xAttr() { return ['src', 'selected', 'checked',  'disabled', 'readonly'] } 
	static ver() { return '.' + Config.VERSION}
	// TODO this can probably be moved to COMPUTED
	static dynamic(item, i, arg) {
		return Config.DELIMITER.BEG + item[arg] + Config.DELIMITER.END
	}

	attributeChangedCallback(name, oldVal, newVal) {
		//TODO do we need length???
		if (newVal.length > 0 && oldVal !== newVal) {
			if (name === 'doo-db-update') {
					this.data[this.getAttribute('doo-db')] = Doo.DB.data(this.getAttribute('doo-db'))
					this.render()
			}
			else if (name === 'page-size') {
				this.PAGE_SIZE = newVal
			}	
			else if (name === 'debug') {
				this.debug = true
			}	
		}	
	}
	
	constructor(pageSize=5000) {
		super()
		this.renderOnLoad = true
		this.startTime = (new Date().getTime())
		this.PAGE_SIZE = pageSize
		//this.template = this.template || this.getAttribute('template')
		this.filteredData = {}
		this.visibleColumns = []
		this.place = []
		if (document.title.indexOf('(') < 0) {
			document.title += ' (' + Doo.ver() + ')'
        }
    }
	
	//TODO add static debug flag and only log when in debug mode
	async connectedCallback() {
		let tag = this.constructor.name.toLowerCase()
		console.log(`Custom tag added: <doo-${tag} />`)
		if (this.renderOnLoad) {
			await this.render()  
		}	
	}

	static define( klass) {
		customElements.define('doo-' + klass.name.toLowerCase(), klass)
	}	
	
	//TODO rename and make shorter
	setShadowAttribute(selector, attr, value) {
		const elements = this.shadowRoot.querySelectorAll(selector)
		const len = elements.length
		for (let i=0; i<len; i++) {
			elements[i].setAttribute(attr, value)
		}
	}

	getFilteredData(name) {
		return this.filteredData[name]
	}

	//TODO make sure it works with this.getItemValue() and move to computed
        
	// TODO maybe call in base constructor ???
	// suport multiple db names "abc, xyz" => [
    /*
    setDooDB(name=null) {
		const dbName = name ? name : this.getAttribute('doo-db')
		if (dbName) {
			this.classList.add("doo-db::" + dbName)
		}
	}
     */
    //TODO I think we can use documentOrShadowRoot see MDN
    getNode(selector, docOrShadow=this.shadowRoot) {
    	return docOrShadow.querySelectorAll(selector)[0]
    } 

	async setTemplate(argTpl, doc) {
    	let tpl = (argTpl.indexOf('<template') === 0) ? argTpl : '' 
		if (this.firstElementChild && this.firstElementChild.getElementsByTagName('template').length > 0)   {
    			tpl = this.firstElementChild.getElementsByTagName('template')[0].outerHTML
    		} else {
    			tpl = await this.getTemplateURI(argTpl, doc) 
		}
		let elem = document.createElement('div')
		elem.innerHTML = tpl
		if (elem.querySelector('template')) {
			//TODO create ERROR slot or Config constance
			elem.innerHTML = elem.querySelector('template') ? tpl : `<template><center><pre>The template you are trying to import does not have a &lt;template&gt tag</pre><div style="color:red">${argTpl}</div></enter></template>`
		}
		this.templateNode = elem.querySelector('template').cloneNode(true)
		this.templateNode.removeAttribute('id')

	}

	async getTemplateURI(url) {
		let tpl
		if (url.indexOf('#') === 0) {
			tpl = await document.querySelector(url).outerHTML
		} else {
			//TODO remove script tags
			tpl = await this.fetchURL(url)
		}
		return tpl
	}
    
	parse(argDataNode) {
		//TODO remove HTML comments
		//TODO replace {{}} in <code></code> and <pre></pre> with escaped "\{\{" 
		//TODO Allow for nested {{xxx{{yyy}}zzz}}
		let tplNode = argDataNode.cloneNode(true)
		tplNode.removeAttribute('data-set')
		tplNode.removeAttribute('dynamic')
		let htmlStr = tplNode.outerHTML.replace(/\t/g, '').replace(/\n/g, '')
		let orgStr = htmlStr
		//covers checked="false" where browser returns true 
		//TODO: check modern browser to see if it still is an issue
		Doo.xAttr().forEach(item => {
			htmlStr = htmlStr.replace(new RegExp(' ' + item + '="\{\{(.+)}}"', 'g'), ' doo-' + item + '="{{$1}}"')
		})

		let xHtml = (orgStr === htmlStr)
		if (window[this.constructor.name] === undefined) {
            window[this.constructor.name] = []
		} 
		//TODO bind(this)
		let inst =  window[this.constructor.name].length
		htmlStr = htmlStr.split('="self.').join('="' + this.constructor.name + '[' + inst + '].');

		let aHTML = htmlStr.split(Config.DELIMITER.END)
	
		let templateArray = []
		let len = aHTML.length
		let aStr
		for (let i=0; i<len; i++) {
			aStr = aHTML[i].split(Config.DELIMITER.BEG)
			templateArray.push(aStr[0])	
			templateArray.push(this.getPropertyType(aStr[1]))		
		} 
		return {templateArray:templateArray,xHtml:xHtml}
	}

	getPropertyType(fld) {
		if (fld === undefined) {
			return new FieldType('', undefined, this.constructor, this)
		}	
		fld = fld.trim()
		let type = Config.TYPE.DEFAULT
		if (fld.indexOf('(') > -1) {
			type = Config.TYPE.COMPUTED 
 		} else { 
			if (fld.indexOf(".") > 0) {
				type = Config.TYPE.DEEP
			} else if (!isNaN(fld)) {
				type = Config.TYPE.ENUM
			}
		}
	
		let fieldType = new FieldType(fld, type, this.constructor, this)

        //TODO this needs to be sco0ped	
		this.visibleColumns.push(fld) 
		fieldType.parentElem = this.parentElement
 		return fieldType
	}
	
	getItemValue(item, prop) {
		if (typeof prop === 'function') {
			return this[prop](item)
		}
		let curValue = item
		try { 
			prop.split('.').forEach(key => curValue = curValue[key])
		} catch(e) {
			console.log('Property not found', aProp, curValue)
		}
		return curValue
	}

	// TODO combind first 2 parmeters
	renderNode(templateArray, xHtml, data, start = 0, pgSize = this.PAGE_SIZE, dataElem) {
		
		data = Array.isArray(data) ? data : [data]
		let dataLen = data.length
		let stop = start + pgSize
		if (stop > dataLen) { stop = dataLen }
	
		let html = []
		for (let i = start; i<stop; i++) {
			for (let j=0, len = templateArray.length; j<len; j=j+2) {
				html.push(templateArray[j])

                let templateFldObj = templateArray[j+1]
 				switch (templateFldObj.type) {
					case (Config.TYPE.DEFAULT): 
					case (Config.TYPE.DEEP):
   					    html.push(this.getItemValue(data[i],templateFldObj.fld))
						break
					case (Config.TYPE.ENUM):
						html.push(data[i])
						break
					case (Config.TYPE.COMPUTED):
						// TODO should probably be static for speed
						let dataItem = new DataItem(data[i], i, data)
						//dataItem.dataSetName = dataElem.dataKey   //TODO TEST
						dataItem.fld = templateFldObj.fld
						dataItem.func = templateFldObj.func
						dataItem.$1 = templateFldObj.$1
						dataItem.$2 = templateFldObj.$2
						dataItem.instance = templateFldObj.instance
						html.push(templateFldObj.func(dataItem))
						//dataItem = undefined  //TODO check to see if this gets released right away, or do we need to set it to undefined  
                        break
					case (undefined):
						html.push('')
				}
			}
		}
		if (xHtml) {
			return html.join('')
		} else {	
			let htmlStr = html.join('')
			Doo.xAttr().forEach(item => {
				if (item === 'checked' || item ==='disabled') {
					htmlStr = htmlStr.replace(new RegExp(' doo-' + item + '="false"', 'g'), ' ')
							.replace(new RegExp(' doo-' + item + '="0"', 'g'), ' ')
				}
				htmlStr = htmlStr.replace(new RegExp(' doo-' + item + '=', 'g'), ' '+ item + '=').replace(new RegExp(' ' + item + '=""', 'g'), ' ');

			})
			return htmlStr
		}
	}
	
	getLevel(dataSetElem) {
		let level = 0
		while (dataSetElem.parentElement) {
			dataSetElem = dataSetElem.parentElement
			level++
		}
		return level;
	}

	//TODO
	clearDataFilter(dataSetName) {
		this.filteredData[dataSetName] = undefined
	}

    //TODO make filter criteria object
	//TODO make static filter RecCount and Total RecCount
	setDataSearchFilter(dataSetName, matchType = Config.MATCH.ANY) {
	}	
	setDataFilter(dataSetName, criteria) {
    	 
        let filterKey = this.filterKey && this.filterKey.toLowerCase()
		//TODO let data = [...this.data[dataSetName]] insted of slice
		let data               = this.data[dataSetName].slice()
		let me = this
		if (criteria) {
			data = data.filter(criteria)
		} else if (filterKey) {
			filterKey =String(filterKey)
			//TODO set filter only and filter the data during renderNode method
			data = data.filter(row => me.visibleColumns.some(key => String(me.getItemValue(row, key)).toLowerCase().indexOf(filterKey)>-1))
		}	
		this.filteredData[dataSetName]  = data.slice(0, this.page_size)
	}
	//TODO 
	dataSetType(type) {
		switch (type) {
			case LOCAL_JSON:
			case CSV:
			case YAML:
			case WINDOW:
			case INLINE_ARRAY:
			case RANGE:
		}
	}
		
	async initDataNodes() {
		let reactiveElems = this.templateNode.content.querySelectorAll('[data-set]')
		let len = reactiveElems.length
		let i = 0
		let reactiveElem = [], dataElem
		for (i=0;i<len;i++) {
			//TODO establish data-set types call this.dataSetTypes() and make more elegant
			let dataSrc = reactiveElems[i].getAttribute('data-set')
			if (dataSrc.indexOf('href') === 0) { 
				let key = dataSrc.substring(dataSrc.lastIndexOf('/')+1).split('.')[0]
				let data = await this.fetchURL(dataSrc)
				this.data['key' + '_href'] = JSON.parse(data)[key]
				reactiveElems[i].setAttribute('data-set',key+'_href')
			} else if (dataSrc.indexOf('.json') > 0) { 
				let key = dataSrc.substring(dataSrc.lastIndexOf('/')+1).split('.')[0]
				let data = await this.fetchURL(dataSrc)
				this.data[key+'_json'] = JSON.parse(data)[key]
				reactiveElems[i].setAttribute('data-set',key+'_json')
			} else if (dataSrc.indexOf('.js') > 0) { 
				let key = dataSrc.substring(dataSrc.lastIndexOf('/')+1).split('.')[0]
				let data = await import(dataSrc)
				this.data[key] = data.default
				reactiveElems[i].setAttribute('data-set',key)
			} else if (dataSrc.indexOf('this.') > 0) { 
				let key = dataSrc.split('.')[1]
				reactiveElems[i].setAttribute('data-set',key)
			//TODO do a common .. splitter that returns a range object
			} else if (dataSrc.indexOf('..') > 0) { 
				dataSrc = dataSrc.replace('[','').replace(']','')
				let range = dataSrc.split('..')
				let arr = []
				let isAlpha = isNaN(range[0])
				let start = parseInt(isAlpha ? range[0].charCodeAt(0) : range[0])
				let stop = parseInt(isAlpha ? range[1].charCodeAt(0) : range[1])
				for (let j=start; j<=stop; j++) {
					arr.push(isAlpha ? String.fromCharCode(j) : j )
				}
				let key = 'doo_array_' + range[0] + '_' + range[1]
				this.data[key] = arr.splice(0)
				reactiveElems[i].setAttribute('data-set',key)
			} else if (dataSrc.indexOf('[') === 0) {
				let dataKeyValues = dataSrc.replace('[','').replace(']','').split(',')
				//TODO make sure it gets alltrimmed	
				dataKeyValues.forEach(item=>item.trim())
				this.data[dataKeyValues.join('_')] = dataKeyValues
				reactiveElems[i].setAttribute('data-set',dataKeyValues.join('_'))
			} else if (dataSrc.indexOf('window.') > 0) { 
				let key = dataSrc.split('.')[1].trim() 
				this.data[key] = window[key.split('.').join('_')]
				reactiveElems[i].setAttribute('data-set',key)
			} else if (dataSrc.indexOf('.count') > 0) { 
				let key = dataSrc.split('.')[0].trim()
				reactiveElems[i].count = this.data[key].length 	
			} 
			reactiveElems[i].level = this.getLevel(reactiveElems[i])
			reactiveElem.push(reactiveElems[i])
		}

		const orderByLevel = (a,b) => {
			return ((a.level === b.level) ? 0 : (a.level > b.level) ? 1 : -1)
		}
		reactiveElem.sort(orderByLevel).reverse()
		
		for (i=0;i<len;i++) {
			let isDynamic = reactiveElem[i].getAttribute('dynamic')  //TODO doo-dynamic

			if ('|STYLE|LINK|'.indexOf(`|${reactiveElem[i].tagName}|`) >-1) {
				dataElem = reactiveElem[i]
			} else if (reactiveElem[i].parentElement && '|TBODY|THEAD|TFOOT|TR|SELECT|'.indexOf(`|${reactiveElem[i].parentElement.tagName}|`) >-1) {
				//TODO remove slots or elem with doo-static attribute, and put as first child after render 
				dataElem = reactiveElem[i].parentElement
			} else {
				dataElem = document.createElement('data')	
			}
			dataElem.dataKey = reactiveElem[i].getAttribute('data-set')
			let parsedNode = this.parse(reactiveElem[i])
			dataElem.templateArray = parsedNode.templateArray 	
			dataElem.xHtml = parsedNode.xHtml 	
			dataElem.name = i
			dataElem.level = this.getLevel(reactiveElem[i])

			if (isDynamic) {dataElem.isDynamic = true}
//WIP
//			if (dataElem.count) {
//				dataElem.innerHTML = this.renderNode(dataElem.templateArray, dataElem.xHtml, this.data[dataElem.dataKey],  0, 0)
//			} else {
				dataElem.innerHTML = this.renderNode(dataElem.templateArray, dataElem.xHtml, this.data[dataElem.dataKey],  0, this.PAGE_SIZE, dataElem)
//			}
			if (dataElem.tagName === 'DATA' || dataElem.tagName === 'STYLE' || dataElem.tagName === 'LINK') {
				//TODO allow for templates not to require single root node 
				if (reactiveElem[i].parentElement) {
					reactiveElem[i].parentElement.replaceChild(dataElem, reactiveElem[i])
				} else {
					//TODO consider adding single child node on the fly
					console.log('Warning: Templates should only have one childnode')
					reactiveElem[i].appendChild(dataElem)					
				}	
			}
			this.place.push(dataElem)
		}
	}
	
	async render(dataSetName=null, idx=null) {
		if (!this.templateNode) {
			if (!this.template) {
				console.log(this.name + ' has no template defined')
				return
			} 
			console.log('Template:', this.template)
			await this.setTemplate(this.template)
			this.setTemplate(this.template)
	
		}
		if (this.templateElem === undefined) {

    		// TODO warn when there are multiple children (maybe not needed, not sure)
			/*	if (!this.templateNode.content.parentElement) {
	        		let tplRootNode = document.createElement('section');
	        		tplRootNode.innerHTML = this.templateNode.innerHTML
	        		this.templateNode.innerHTML = tplRootNode.outerHTML
	        	}
			*/
				//TODO implement css="inherit" and use https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot to bring them in
	    		if (this.shadow === undefined && this.getAttribute('css')) {
					let cssList = this.getAttribute('css').split(',')
					let len = cssList.length 
					for (let i=0;i<len;i++) {
						let link = document.createElement('link')
						link.href = cssList[i]
						link.rel = "stylesheet"
						this.templateNode.content.firstElementChild.parentNode.insertBefore(link, this.templateNode.content.firstElementChild)
					}
				}
	        	this.templateElem = this.templateNode.content

			// TODO I think this block only is needed if this.shadow === undefined	
			let styleNode = 	this.templateElem.querySelectorAll('style')
			//TODO support multiple style nodes within the template
			if (styleNode && styleNode.length > 0) {
				this.templateElem.appendChild(styleNode[0])
			}
		}
		if (this.place.length === 0) {
			this.initDataNodes()
			this.templateNode.setAttribute('style', this.getAttribute('style'))
		} 
		let x = new Date().getTime()
		let len = this.place.length
		for (let i=0;i<len;i++) {
			if (dataSetName && dataSetName !== this.place[i].dataKey) {
				continue   // TODO other data-sets that are children of the specified data set proably needs to be re-rendered (needs test scenarios)
			}
			if (this.place[i].tagName !== 'STYLE') {
				this.place[i].setAttribute("page",0);
			}	
			if (this.place[i].isDynamic) {continue}

			let data = this.getFilteredData(this.place[i].dataKey) ? this.getFilteredData(this.place[i].dataKey) : this.data[this.place[i].dataKey]
			// TODO allow for single node replacement		
	//		if (idx === null) {
				// TODO combined first 2 parameter as a parsedTemplateArrayObject
				this.place[i].innerHTML = this.renderNode(this.place[i].templateArray, this.place[i].templateArray.xHtml, data,  0, this.PAGE_SIZE)

				//		} else {
	//			let elem = document.createElement('data')
				// TODO combined first 2 parameter as a parsedTemplateArrayObject
	//			this.place[i].parentElement.replaceChild(this.renderNode(this.place[i].templateArray,this.place[i].templateArray.xHtml, data,  idx, idx, me), this.place[i].parentElement.childNodes[idx]) 
	//		}	
		}
		if (!this.shadow) {
			this.shadow = this.attachShadow({mode: 'open'})
			//TODO tie this to the Doo object and bind it more elegantly
			if (!window[this.constructor.name]) {
				window[this.constructor.name] = []
			}
			window[this.constructor.name].push(this)
			if (this.childNodes.length >0) {
            	this.removeChild(this.getElementsByTagName('template').item(0))
			}	

			/*
			WIP
			let eventNodes = this.templateElem.querySelectorAll('[attach]')
			console.log(eventNodes.length)
			console.log(eventNodes[0].getAttribute('attach'))
			eventNodes[0].getAttribute('attach')
			eventNodes[0].removeAttribute('attach')
*/
			

			this.shadow.appendChild(this.templateElem)
			
		} 
		if (!this.getAttribute('title')) {
			this.setAttribute('title', 'Init: ' + (new Date().getTime() - this.startTime) + 'ms')
		}
		let renderTime = (new Date().getTime() - x) + 'ms'
		this.setAttribute('doo-render-time', renderTime)
		this.setAttribute('title', this.getAttribute('title') + '|' + renderTime)

	}	

	//TODO rename
	async fetchURL(url) {
		return new Promise((resolve, reject) => {
		  const xhr = new XMLHttpRequest()
		  xhr.open("GET", url)
		  xhr.onload = () => resolve(xhr.responseText)
		  xhr.onerror = () => reject(xhr.statusText)
		  xhr.send();
		})
	  }

	//TODO deprecated
	setHttpRequest(url, callback) {
		let me = this
		let xhr = new XMLHttpRequest();
		xhr.onload = function () { 
			callback(this.responseText, me) 
		}
		xhr.open('GET', url, true)
		xhr.send()
	}
}

Doo.LS = {
	//TODO implement similar to Doo.DB and do CRUD operation on localStorage (goto town Lindsay)
	//Next step will be to make this an interface that will work the same way on a remote storage or an established store like vueX or Redux
}

//TODO convert to class with static getters and setters(maybe) 
Doo.DB = {
		'dataSet':{},
		'data':
		function(name)  {	
			if (!this.dataSet[name]) {
				this.dataSet[name] = []
			}
			return this.dataSet[name]
		},	
		'prepend':
		(name, obj) => {	
			this.append(name, obj, true)
		},	
		
		'append':
		function(name, obj, top = null) {
			//TODO this can all be done with splice
			if (Array.isArray(obj)) {
				this.dataSet[name] = (top) ? [obj].concat(this.data(name)) : this.data(name).concat(obj) 
			} else { 
				(top) ? this.dataSet[name].splice(0,0,obj) : this.dataSet[name].push(obj) 
			}	
			//this.refresh(name)
		},
		'update':
		function(name, obj, idx) {
			this.data(name).splice(idx,1,obj)
			//this.refresh(name)
		},
		'refresh':
		function(name, doc = document) {
			const subscriber = doc.querySelectorAll("[doo-db='" + name +"']")
			const len = subscriber.length
			for (let i=0; i<len; i++) {
				subscriber.item(i).setAttribute('doo-db-update', new Date().getTime())
			}
		},
		'csvToJson':
		function(csvText) {
	    	let rows = csvText.split("\n")
	    	let data = []
			if (rows !== undefined) {
				let rowsLen = rows.length
				let fieldDesc = rows[0].replace(/\r/g, '')
				let cols = fieldDesc.split(",")
				let colLen = cols.length

				if (rows.length > 1) {
					let re = new RegExp('(,)(?=(?:[^"]|"[^"]*")*$)','g')
					for (let i=1;i<rowsLen-1;i++) {
						let obj={}
						let rowStr = rows[i].replace(re, '|^|') + '|^|'	
						let row = rowStr.split('|^|')
						for (let j=0;j<colLen;j++) {
							obj[cols[j]] = (row[j]) ? row[j].replace(/"/g, '').trim() : ''
						}	
						data.push(obj)
					}	
				}
			}
			return data
		}
}

Doo.util = {
		'createMockData':
		function(argArr, argCnt) {
			let cnt = argArr.length + ""	
			let lname = ["Smith","Johnson","Doe","Jobs","Gates","Bezos","Buffet","Bloomberg","Ellison","Walton"]
			let fname = ["Jessica", "Cindy", "Jane", "Steve", "Bill", "Jeff", "Warren", "Michael" ,"Larry", "Jim" ]	
			let location = [{"city":"Los Angeles","state":"CA","country":"USA", "areacode":"310","code":"us"}, 
				{"city":"San Francisco","state":"CA","country":"USA","areacode":"415","code":"us"},
				{"city":"Portland","state":"OR","country":"USA","areacode":"503","code":"us"},
				{"city":"Palo Alto","state":"CA","country":"USA","areacode":"408","code":"us"},
				{"city":"Bellevue","state":"WA","country":"USA","areacode":"306","code":"us"},
				{"city":"Dallas","state":"TX","country":"USA","areacode":"214","code":"us"},
				{"city":"New York","state":"NY","country":"USA","areacode":"206","code":"us"},
				{"city":"Stockholm","state":"SWE","country":"Sweden","areacode":"046","code":"se"},
				{"city":"Mariehamn","state":"FIN","country":"Aland Islands","areacode":"058","code":"ax"},
				{"city":"Memphis","state":"TN","country":"USA","areacode":"901","code":"us"}

				];
				
			var randomDate = function( start, end ) {
		    		return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
			}
			
			let json = [];
			let obj;
			for (let i=0;i<argCnt;i++) {
				obj={};
				let x = parseInt(Math.random()*10, 10);
				obj.fname = fname[x];
				obj.sex = (x>2) ? 'M' : 'F';
				obj.lname = lname[parseInt(Math.random()*10, 10)];
				obj.middle = String.fromCharCode(parseInt(Math.random()*10000/26 % 26, 10)+65);
				obj.userId = (++cnt);
				obj.user = (obj.fname.substr(0,1)+obj.lname +(obj.userId)).toLowerCase();
				obj.date = randomDate(new Date(2012, 0, 1), new Date());
				let loc = parseInt(Math.random()*10, 10);
				obj.location =  location[loc];
				obj.lorem = COMPUTED.lorem()
	 
				json.push(obj);
			}
			return json;
		},
		'addEvent':
		function (obj, event_name, func_name, argBoolean) {
			if (obj && func_name) {
				if (obj.attachEvent) {
					obj.attachEvent("on" + event_name, func_name);
				} else if (obj.addEventListener) {
					argBoolean = (typeof argBoolean === this.BOOLEAN) ? argBoolean : true;
				    if(event_name === 'mousewheel') {
				    		obj.addEventListener('DOMMouseScroll', func_name, argBoolean);  
					}
					obj.addEventListener(event_name, func_name, argBoolean);
				} else {
					obj["on" + event_name] = func_name;
				}
			}
		},
		//TODO replace with a minimized version of natrual order
		'sortBy':
		function(data, argSortArray, argDirection) {
			if (data.length < 1) { 
				return;	
			}

			const comparator = {

				'getValue':
				(item, prop ) => {
					var aProp = prop.split('.');
					var curValue = item;
					for (var j=0;j<aProp.length;j++) {
						curValue = curValue[aProp[j]];
					}
					return curValue;
				},  

				'getDataType':
				function(argFld, argArray) {
					if (typeof argFld === 'object') { return 'byFunc'; }
					
					var val = this.getValue(argArray[0],argFld);
			
					if (val && val.toString().indexOf("/") > 0 && new Date(val) && !isNaN(new Date(val).getTime())) {return 'byDate'; }
					for (var i=0; i<argArray.length; i++) {
						if (isNaN(this.getValue(argArray[i],argFld))) {
							return 'byString';  
						}
					}
					return 'byNumber';
				},

				'byFunc':
				function(a, b, obj, i) {
					var fn = obj[i].cmd;
					var fa = fn.call(this, (obj[i].dir === -1 ? b : a), obj[i].param, argDirection );
					var fb = fn.call(this, (obj[i].dir === -1 ? a : b), obj[i].param, argDirection );
					if  (fa < fb) {return -1;}
					if  (fa > fb) {return 1;}
					return (typeof obj[i+1] != 'undefined') ? comparator[obj[i+1].type](a,b, obj, i+1) : (a.$_id - b.$_id);
				},       

				'byDate':
				function(a, b, obj, i) {
					var fld = obj[i].fld.replace(Config.DELIMITER.BEG,'').replace(Config.DELIMITER.END,'')
					var da = this.getValue((obj[i].dir === -1 ? b : a),fld);
					var db = this.getValue((obj[i].dir === -1 ? a : b),fld);
					if (!da.getTime && !db.getTime) {
						da = new Date(da);
						db = new Date(db);
					}
					da = da.getTime();
					db = db.getTime();
					if  (da < db) {return -1;}
					if  (da > db) {return 1;}                   
					return (typeof obj[i+1] != 'undefined') ? comparator[obj[i+1].type](a,b, obj, i+1) : (a.$_id - b.$_id);
					},

				'byString':
				function(a, b, obj, i) {
					var fld = obj[i].fld.replace(Config.DELIMITER.BEG,'').replace(Config.DELIMITER.END,'')
					var sa = comparator.getValue(obj[i].dir === -1 ? b : a, fld).toUpperCase()
					var sb = comparator.getValue(obj[i].dir === -1 ? a : b, fld).toUpperCase()
					if  (sa < sb) {return -1;}
					if  (sa > sb) {return 1;}
					return (typeof obj[i+1] != 'undefined') ? comparator[obj[i+1].type](a,b, obj, i+1) : (a.$_id - b.$_id);

				},

				'byNumber':
				function(a, b, obj, i) {
					var fld = obj[i].fld.replace(Config.DELIMITER.BEG,'').replace(Config.DELIMITER.END,'')
					var na = Number(this.getValue((obj[i].dir === -1 ? b : a),fld));
					var nb = Number(this.getValue((obj[i].dir === -1 ? a : b),fld));
					if  (na < nb) {return -1;}
					if  (na > nb) {return 1;}
					return (typeof obj[i+1] != 'undefined') ? comparator[obj[i+1].type](a,b, obj, i+1) : (a.$_id - b.$_id);
				}
		    };
		    var sortObjects = [];
			if (typeof argSortArray === 'string') {
				argSortArray = [argSortArray, argDirection || 1];
			}
		    
		    if (argSortArray) {
		        for (var k=0;k<argSortArray.length;k=k+2) {
		            sortObjects.push({'fld' : argSortArray[k],
		                             'dir' : Number((argSortArray[k+1] || 1)),
		                             'type' :comparator.getDataType(argSortArray[k], data)
		                             }                                    
		            );
		        }
		    }
		    // TODO to guarantee that the order stays the same when toggle sort when equal
		    // TODO should only do this one time
		    if (data.length > 0 && typeof data[0].$_id === "undefined") {
		    	let len = this.length
		        for (var n=0;n<len;n++) {
		            data[n].$_id = Number(n);
		        }
		    }
		    data.sort(function(a,b) {return comparator[sortObjects[0].type](a, b, sortObjects, 0)});
		}

}
class FieldType {
	constructor(fld, type, klass, instance) {
		this._fld = fld
		this.type = type
		this.klass = klass
		this.instance = instance
		this._func = undefined
		this._parentElem = undefined
		this.$1 = undefined
		this.$2 = undefined
		if (this.type === Config.TYPE.COMPUTED) { 
			this.createComputed()
		}	
	}
	set fld(fld) {this._fld=fld}
	set parentElem(parentElem) {this._parentElem = parentElem} 
	set func(func) {this._func = func}
	get fld() {return this._fld}
	get func() {return this._func}

	createComputed() {
		//TODO create a regEx for more elegant parsing
		let breakParams = this.fld.split('(')
		let computedArr = breakParams[0].split('.').reverse()
		let funcName = computedArr[0]
		if (Reflect.ownKeys(this.klass).filter(key=>key===funcName).length > 0) {
			this.func = this.klass[funcName]
			if (COMPUTED[funcName]) {
				console.log('WARNING:', 'Overwriting a Doo base COMPUTED method is not recommended' );
			}
		} else if (COMPUTED[funcName]) { 	
			this.func = COMPUTED[funcName]
		}
		this.fld = computedArr.length > 1 ? computedArr[1] : undefined
		if (typeof this.func !== 'function') {
			console.log('static ' + func + '() is not a defined on the Doo base class nor as a static member function')
			type = undefined
		}
		let params = breakParams[1].replace(')','')
		if (params && params.length > 0) {
			params = params.split(',')
			for (let k=0,len=params.length;k<len;k++ ) {
				this['$'+(k+1)]= params[k]
			}
		}
	} 
}

//TODO rename to just Data (maybe) and move all computed methods into here
class DataItem {
	constructor(item, i, arr) {
		this.item = item
		this.i = i
		this.arr = arr
		
		this._dataSetKey = ''
		this._fld = ''
		this._args = []
		this._searchable = true
	}

	set dataSetKey(dataSetKey) {this._dataSetKey=dataSetKey}
	set fld(fld) {this._fld=fld}
	set args(args) {this._args=args}
    set filterKey(filterKey) {this._filterKey=filterKey}
	set searchAble(searchAble) {this._searchAble = new Boolean(searchAble)}

	get fld() {return this._fld}
    get length() {return this.arr.length}
    get filterKey() {return this._filterKey}

	isSearchable() {
		return this.searchable
	}
	getValue() {
        return this.item[this.fld]
    }
	toString() {
        return JSON.stringify(this.item)
    }
 	highlight() {
		if (this.fld) {
			let filterKey = this.filterKey && this.filterKey.toLowerCase()
			if (!filterKey) {return item[field]}
			let re = new RegExp(filterKey, "ig")
			let value = this.getValue().toString().replace(/&amp\;/gi,'&')
			return value.replace(re, (txt) => {return ('<b>' + txt + '</b>')})
		}

	}
}
class Import extends Doo {
	constructor() {
	  super()
      this.load()  
    }
   
	async load() {
	  await import(this.getAttribute('from'))
	} 
}
if (!customElements.get('doo-import')) { 
    Doo.define(Import)
}
export {Doo as default, 
    COMPUTED,
    Config,
    FieldType,
    DataItem,
    EMPTY_ROW
}


